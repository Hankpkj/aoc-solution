// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Curry = require("rescript/lib/js/curry.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Belt_MapString = require("rescript/lib/js/belt_MapString.js");
var Belt_SetString = require("rescript/lib/js/belt_SetString.js");

var input = Fs.readFileSync("input/Week1/Year2020Day4.sample.txt", "utf8");

var $$require = Belt_SetString.fromArray([
      "byr",
      "hcl",
      "pid",
      "ecl",
      "iyr",
      "hgt",
      "eyr"
    ]);

function parsing(s) {
  return Belt_SetString.fromArray(Belt_Array.keep(Belt_Array.map(s.replace(/[\s]+/g, " ").split(/[\s]+/g), (function (str) {
                        return Belt_Option.mapWithDefault(str, "", (function (x) {
                                        return x;
                                      })).replace(/:[\w#]+/, "");
                      })), (function (x) {
                    return x !== "";
                  })));
}

function judge(s) {
  return Belt_SetString.size(Belt_SetString.intersect(s, $$require)) === 7;
}

console.log(Belt_List.size(Belt_List.keep(Belt_List.map(Belt_List.fromArray(input.split("\n\n")), parsing), judge)));

function toSingleLine(s) {
  return s.replace(/[\s]+/g, " ");
}

function id(s) {
  return s;
}

function toTuple(s) {
  if (s.length !== 2) {
    return ;
  }
  var a_ = s[0];
  var b_ = s[1];
  return [
          a_,
          b_
        ];
}

function j(p, s, f) {
  var g = Belt_MapString.get(p, s);
  if (g !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(g));
  } else {
    return false;
  }
}

function parseToMap(s) {
  return Belt_MapString.fromArray(Belt_Array.keepMap(Belt_Array.map(Belt_Array.map(Belt_Array.keepMap(toSingleLine(s).split(/[\s]+/g), id), (function (s) {
                            return s.split(":");
                          })), toTuple), id));
}

function optionalNumberTest(t, max, min) {
  if (t === undefined) {
    return false;
  }
  var v = Caml_option.valFromOption(t);
  if (Caml_obj.caml_lessequal(v, max)) {
    return Caml_obj.caml_greaterequal(v, min);
  } else {
    return false;
  }
}

var numberTestPair = {
  hd: [
    "byr",
    [
      2002,
      1920
    ]
  ],
  tl: {
    hd: [
      "iyr",
      [
        2020,
        2010
      ]
    ],
    tl: {
      hd: [
        "eyr",
        [
          2030,
          2020
        ]
      ],
      tl: /* [] */0
    }
  }
};

function yearTest(m) {
  return Belt_List.reduce(numberTestPair, true, (function (acc, param) {
                var match = param[1];
                var get = Belt_MapString.get(m, param[0]);
                var result = get !== undefined ? /^[1-9][0-9]{3}$/.test(get) && optionalNumberTest(Belt_Int.fromString(get), match[0], match[1]) : false;
                if (result) {
                  return acc;
                } else {
                  return false;
                }
              }));
}

var regexTestPair_0 = [
  "hcl",
  /^#[a-f0-9]{6}$/
];

var regexTestPair_1 = {
  hd: [
    "ecl",
    /^(?:amb|blu|brn|gry|grn|hzl|oth)$/
  ],
  tl: {
    hd: [
      "pid",
      /^[0-9]{9}/
    ],
    tl: /* [] */0
  }
};

var regexTestPair = {
  hd: regexTestPair_0,
  tl: regexTestPair_1
};

function regexTest(m) {
  return Belt_List.reduce(regexTestPair, true, (function (acc, param) {
                var get = Belt_MapString.get(m, param[0]);
                var result = get !== undefined ? param[1].test(get) : false;
                if (result) {
                  return acc;
                } else {
                  return false;
                }
              }));
}

function hgtRegexTest(v) {
  if (/^[0-9]{2}[in]{2}$/.test(v)) {
    return optionalNumberTest(Belt_Int.fromString(v), 76, 59);
  } else if (/^[0-9]{3}[cm]{2}$/.test(v)) {
    return optionalNumberTest(Belt_Int.fromString(v), 193, 150);
  } else {
    return false;
  }
}

function hgtTEst(m) {
  var get = Belt_MapString.get(m, "hgt");
  if (get !== undefined) {
    return hgtRegexTest(get);
  } else {
    return false;
  }
}

console.log(Belt_Array.keep(Belt_Array.keep(Belt_Array.keep(Belt_Array.map(input.split("\n\n"), parseToMap), yearTest), hgtTEst), regexTest).length);

exports.input = input;
exports.$$require = $$require;
exports.parsing = parsing;
exports.judge = judge;
exports.toSingleLine = toSingleLine;
exports.id = id;
exports.toTuple = toTuple;
exports.j = j;
exports.parseToMap = parseToMap;
exports.optionalNumberTest = optionalNumberTest;
exports.numberTestPair = numberTestPair;
exports.yearTest = yearTest;
exports.regexTestPair = regexTestPair;
exports.regexTest = regexTest;
exports.hgtRegexTest = hgtRegexTest;
exports.hgtTEst = hgtTEst;
/* input Not a pure module */
