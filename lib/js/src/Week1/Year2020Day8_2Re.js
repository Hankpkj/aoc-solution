// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Input = require("../Util/input.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_SetInt = require("rescript/lib/js/belt_SetInt.js");

var arr = Input.Input.get(/* Single */0, 8);

function pair(i, v) {
  return {
          index: i,
          value: v
        };
}

function pendingData(i, cPair, nPair, set, prevJmp) {
  return {
          instruction: i,
          current: cPair,
          prev: nPair,
          setFromPrev: set,
          prevJmp: prevJmp
        };
}

function makeInstruction(s) {
  var match = s.split(" ");
  if (match.length !== 2) {
    return ;
  }
  var match$1 = match[0];
  switch (match$1) {
    case "acc" :
        var v = match[1];
        return Belt_Option.map(Belt_Int.fromString(v), (function (t) {
                      return {
                              TAG: /* Acc */1,
                              _0: t
                            };
                    }));
    case "jmp" :
        var v$1 = match[1];
        return Belt_Option.map(Belt_Int.fromString(v$1), (function (t) {
                      return {
                              TAG: /* Jmp */0,
                              _0: t
                            };
                    }));
    case "nop" :
        return /* Nop */0;
    default:
      return ;
  }
}

var instructions = Belt_Array.keepMap(arr, makeInstruction);

var length = instructions.length;

function add(set) {
  return function (param) {
    return Belt_SetInt.add(set, param);
  };
}

function addSetFromPending(p) {
  var set = p.setFromPrev;
  return {
          instruction: p.instruction,
          current: p.current,
          prev: p.prev,
          setFromPrev: Belt_SetInt.add(set, p.current.index),
          prevJmp: p.prevJmp
        };
}

function judge(p) {
  if (Belt_SetInt.has(p.setFromPrev, p.current.index)) {
    return {
            TAG: /* Fail */1,
            _0: p.prevJmp
          };
  } else {
    return {
            TAG: /* Success */0,
            _0: addSetFromPending(p)
          };
  }
}

function jump(p, v) {
  return pendingData(p.instruction, {
              index: p.current.index + v | 0,
              value: p.current.value
            }, p.current, p.setFromPrev, p.current);
}

function acc(p, v) {
  return pendingData(p.instruction, {
              index: p.current.index + 1 | 0,
              value: p.current.value + v | 0
            }, p.current, p.setFromPrev, p.prevJmp);
}

function nop(p) {
  return {
          instruction: p.instruction,
          current: {
            index: p.current.index + 1 | 0,
            value: p.current.value
          },
          prev: p.prev,
          setFromPrev: p.setFromPrev,
          prevJmp: p.prevJmp
        };
}

function nextPendingData(p) {
  var v = p.instruction;
  if (typeof v === "number") {
    return nop(p);
  } else if (v.TAG === /* Jmp */0) {
    return jump(p, v._0);
  } else {
    return acc(p, v._0);
  }
}

function $$do(_p) {
  while(true) {
    var p = _p;
    if (p.current.index >= length) {
      return {
              TAG: /* Pass */0,
              _0: p.current
            };
    }
    console.log(p);
    var cInstr = p.current.index === p.prevJmp.index ? /* Nop */0 : Belt_Array.getExn(instructions, p.current.index);
    var pd = judge(nextPendingData({
              instruction: cInstr,
              current: p.current,
              prev: p.prev,
              setFromPrev: p.setFromPrev,
              prevJmp: p.prevJmp
            }));
    if (pd.TAG !== /* Success */0) {
      return {
              TAG: /* NonPass */1,
              _0: pd._0
            };
    }
    _p = pd._0;
    continue ;
  };
}

var initPair = {
  index: 0,
  value: 0
};

var initInstr = Belt_Array.getExn(instructions, 0);

var initPendingData = pendingData(initInstr, initPair, initPair, undefined, {
      index: -1,
      value: 0
    });

console.log($$do(initPendingData));

var initSet;

exports.arr = arr;
exports.pair = pair;
exports.pendingData = pendingData;
exports.makeInstruction = makeInstruction;
exports.instructions = instructions;
exports.length = length;
exports.add = add;
exports.addSetFromPending = addSetFromPending;
exports.judge = judge;
exports.jump = jump;
exports.acc = acc;
exports.nop = nop;
exports.nextPendingData = nextPendingData;
exports.$$do = $$do;
exports.initPair = initPair;
exports.initSet = initSet;
exports.initInstr = initInstr;
exports.initPendingData = initPendingData;
/* arr Not a pure module */
