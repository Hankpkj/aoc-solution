// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Input = require("../Util/input.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Belt_SetString = require("rescript/lib/js/belt_SetString.js");

var input = Input.Input.get(Input.Input.$$double, 4);

var $$require = Belt_SetString.fromArray([
      "byr",
      "hcl",
      "pid",
      "ecl",
      "iyr",
      "hgt",
      "eyr"
    ]);

function id(t) {
  return t;
}

function parsing(s) {
  return Belt_SetString.fromArray(Belt_Array.map(Belt_Array.keepMap(s.replace(/[\s]+/g, " ").split(/[\s]+/g), id), (function (str) {
                    return str.replace(/:[\w#]+/, "");
                  })));
}

function judge(s) {
  return Belt_SetString.size(Belt_SetString.intersect(s, $$require)) === 7;
}

console.log(Belt_List.size(Belt_List.keep(Belt_List.map(Belt_List.fromArray(input), parsing), judge)));

function toSingleLine(s) {
  return s.replace(/[\s]+/g, " ");
}

function intCheck(target, min, max) {
  if (Caml_obj.caml_lessequal(min, target) && Caml_obj.caml_lessequal(target, max)) {
    return Caml_option.some(target);
  }
  
}

function extractIntAndCheck(arr, min, max) {
  if (arr.length !== 2) {
    return ;
  }
  var value = arr[1];
  return intCheck(Belt_Option.mapWithDefault(Belt_Int.fromString(value), 0, id), min, max);
}

function extractStr(arr) {
  if (arr.length !== 2) {
    return ;
  } else {
    return Caml_option.some(arr[1]);
  }
}

var byrRe = /byr:(.*?){4}(?:\s|$)/;

var iyrRe = /iyr:(.*?){4}(?:\s|$)/;

var eyrRe = /eyr:(.*?){4}(?:\s|$)/;

var hgtRe = /hgt:([0-9]{2,3})(in|cm)(?:\s|$)/;

var hclRe = /hcl:(#[a-f0-9]{6})(?:\s|$)/;

var eclRe = /ecl:(amb|blu|brn|gry|grn|hzl|oth)(?:\s|$)/;

var pidRe = /pid:([0-9]{9})/;

var cidRe = /cid:(.*?)(?:\s|$)/;

function parseYear(s, re, minY, maxY) {
  var matched = s.match(re);
  if (matched !== null) {
    return extractIntAndCheck(matched, minY, maxY);
  }
  
}

function checkHgt(h) {
  if (typeof h === "number") {
    return ;
  } else if (h.TAG === /* Cm */0) {
    return intCheck(h._0, 150, 192);
  } else {
    return intCheck(h._0, 59, 76);
  }
}

function extractHgt(arr) {
  if (arr.length !== 3) {
    return /* Bad */0;
  }
  var height = arr[1];
  var sign = arr[2];
  var toInt = Belt_Option.mapWithDefault(Belt_Int.fromString(height), 0, id);
  if (sign === "cm") {
    return {
            TAG: /* Cm */0,
            _0: toInt
          };
  } else {
    return {
            TAG: /* In */1,
            _0: toInt
          };
  }
}

function parseHgt(s) {
  var matched = s.match(hgtRe);
  if (matched === null) {
    return ;
  }
  var hgt = extractHgt(matched);
  if (typeof hgt === "number") {
    return ;
  } else {
    return hgt._0;
  }
}

function parseStr(s, re) {
  var matched = s.match(re);
  if (matched !== null) {
    return extractStr(matched);
  }
  
}

console.log(Belt_Array.keepMap(Belt_Array.map(input, toSingleLine), (function (str) {
            return Belt_Option.flatMap(parseYear(str, byrRe, 1920, 2002), (function (byr) {
                          return Belt_Option.flatMap(parseYear(str, iyrRe, 2010, 2020), (function (iyr) {
                                        return Belt_Option.flatMap(parseYear(str, eyrRe, 2020, 2030), (function (eyr) {
                                                      return Belt_Option.flatMap(parseHgt(str), (function (hgt) {
                                                                    return Belt_Option.flatMap(parseStr(str, hclRe), (function (hcl) {
                                                                                  return Belt_Option.flatMap(parseStr(str, eclRe), (function (ecl) {
                                                                                                return Belt_Option.map(parseStr(str, pidRe), (function (pid) {
                                                                                                              return {
                                                                                                                      byr: byr,
                                                                                                                      iyr: iyr,
                                                                                                                      eyr: eyr,
                                                                                                                      hgt: hgt,
                                                                                                                      hcl: hcl,
                                                                                                                      ecl: ecl,
                                                                                                                      pid: pid,
                                                                                                                      cid: parseStr(str, cidRe)
                                                                                                                    };
                                                                                                            }));
                                                                                              }));
                                                                                }));
                                                                  }));
                                                    }));
                                      }));
                        }));
          })).length);

function parseFnList(t) {
  return [
          parseYear(t, byrRe, 1920, 2002),
          parseYear(t, iyrRe, 2010, 2020),
          parseYear(t, eyrRe, 2020, 2030),
          parseHgt(t),
          parseStr(t, hclRe),
          parseStr(t, eclRe),
          parseStr(t, pidRe),
          parseStr(t, cidRe)
        ];
}

function make(byr, iyr, eyr, hgt, hcl, ecl, pid, cid) {
  return {
          byr: byr,
          iyr: iyr,
          eyr: eyr,
          hgt: hgt,
          hcl: hcl,
          ecl: ecl,
          pid: pid,
          cid: cid
        };
}

function parse(s) {
  var match = parseFnList(s);
  var byr = match[0];
  if (byr === undefined) {
    return ;
  }
  var iyr = match[1];
  if (iyr === undefined) {
    return ;
  }
  var eyr = match[2];
  if (eyr === undefined) {
    return ;
  }
  var hgt = match[3];
  if (hgt === undefined) {
    return ;
  }
  var hcl = match[4];
  if (hcl === undefined) {
    return ;
  }
  var ecl = match[5];
  if (ecl === undefined) {
    return ;
  }
  var pid = match[6];
  if (pid !== undefined) {
    return make(byr, iyr, eyr, hgt, hcl, ecl, pid, match[7]);
  }
  
}

console.log(Belt_Array.keepMap(Belt_Array.map(input, toSingleLine), parse).length);

exports.input = input;
exports.$$require = $$require;
exports.id = id;
exports.parsing = parsing;
exports.judge = judge;
exports.toSingleLine = toSingleLine;
exports.intCheck = intCheck;
exports.extractIntAndCheck = extractIntAndCheck;
exports.extractStr = extractStr;
exports.byrRe = byrRe;
exports.iyrRe = iyrRe;
exports.eyrRe = eyrRe;
exports.hgtRe = hgtRe;
exports.hclRe = hclRe;
exports.eclRe = eclRe;
exports.pidRe = pidRe;
exports.cidRe = cidRe;
exports.parseYear = parseYear;
exports.checkHgt = checkHgt;
exports.extractHgt = extractHgt;
exports.parseHgt = parseHgt;
exports.parseStr = parseStr;
exports.parseFnList = parseFnList;
exports.make = make;
exports.parse = parse;
/* input Not a pure module */
