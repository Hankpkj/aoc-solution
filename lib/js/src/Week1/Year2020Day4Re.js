// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Input = require("../Util/input.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Belt_SetString = require("rescript/lib/js/belt_SetString.js");

var input = Input.Input.get(Input.Input.$$double, 4);

var $$require = Belt_SetString.fromArray([
      "byr",
      "hcl",
      "pid",
      "ecl",
      "iyr",
      "hgt",
      "eyr"
    ]);

function id(t) {
  return t;
}

function parsing(s) {
  return Belt_SetString.fromArray(Belt_Array.map(Belt_Array.keepMap(s.replace(/[\s]+/g, " ").split(/[\s]+/g), id), (function (str) {
                    return str.replace(/:[\w#]+/, "");
                  })));
}

function judge(s) {
  return Belt_SetString.size(Belt_SetString.intersect(s, $$require)) === 7;
}

console.log(Belt_List.size(Belt_List.keep(Belt_List.map(Belt_List.fromArray(input), parsing), judge)));

function toSingleLine(s) {
  return s.replace(/[\s]+/g, " ");
}

function sequence(listOfOptionable) {
  return Belt_List.reduce(listOfOptionable, /* [] */0, (function (acc, optionable) {
                if (acc !== undefined && optionable !== undefined) {
                  return {
                          hd: Caml_option.valFromOption(optionable),
                          tl: acc
                        };
                }
                
              }));
}

function intCheck(target, min, max) {
  var targetToInt = Belt_Option.getExn(Belt_Int.fromString(target));
  if (min <= targetToInt && targetToInt <= max) {
    return String(targetToInt);
  }
  
}

function extractIntAndCheck(arr, min, max) {
  return intCheck(Belt_Array.getExn(arr, 1), min, max);
}

function extractStr(arr) {
  return Belt_Array.get(arr, 1);
}

var byrRe = /byr:(.*?){4}(?:\s|$)/;

var iyrRe = /iyr:(.*?){4}(?:\s|$)/;

var eyrRe = /eyr:(.*?){4}(?:\s|$)/;

var hgtRe = /hgt:([0-9]{2,3})(in|cm)(?:\s|$)/;

var hclRe = /hcl:(#[a-f0-9]{6})(?:\s|$)/;

var eclRe = /ecl:(amb|blu|brn|gry|grn|hzl|oth)(?:\s|$)/;

var pidRe = /pid:([0-9]{9})/;

var cidRe = /cid:(.*?)(?:\s|$)/;

function parseYear(s, re, minY, maxY) {
  var matched = s.match(re);
  if (matched !== null) {
    return extractIntAndCheck(matched, minY, maxY);
  }
  
}

function checkHgt(h) {
  if (typeof h === "number") {
    return ;
  } else if (h.TAG === /* Cm */0) {
    return intCheck(String(h._0), 150, 193);
  } else {
    return intCheck(String(h._0), 59, 76);
  }
}

function extractHgt(arr) {
  if (arr.length !== 3) {
    return /* Bad */0;
  }
  var height = arr[1];
  var sign = arr[2];
  var toInt = Belt_Option.mapWithDefault(Belt_Int.fromString(height), 0, id);
  if (sign === "cm") {
    return {
            TAG: /* Cm */0,
            _0: toInt
          };
  } else {
    return {
            TAG: /* In */1,
            _0: toInt
          };
  }
}

function parseHgt(s) {
  var matched = s.match(hgtRe);
  if (matched === null) {
    return ;
  }
  var hgt = extractHgt(matched);
  if (typeof hgt === "number") {
    return ;
  } else if (hgt.TAG === /* Cm */0) {
    return String(hgt._0) + "cm";
  } else {
    return String(hgt._0) + "in";
  }
}

function parseStr(s, re) {
  var matched = s.match(re);
  if (matched !== null) {
    return Belt_Array.get(matched, 1);
  }
  
}

function apply(s) {
  return {
          hd: Belt_Option.mapWithDefault(parseStr(s, cidRe), "no cid", id),
          tl: {
            hd: parseStr(s, pidRe),
            tl: {
              hd: parseStr(s, eclRe),
              tl: {
                hd: parseStr(s, hclRe),
                tl: {
                  hd: parseHgt(s),
                  tl: {
                    hd: parseYear(s, eyrRe, 2020, 2030),
                    tl: {
                      hd: parseYear(s, iyrRe, 2010, 2020),
                      tl: {
                        hd: parseYear(s, byrRe, 1920, 2002),
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            }
          }
        };
}

function listToPassport(li) {
  if (!li) {
    return ;
  }
  var match = li.tl;
  if (!match) {
    return ;
  }
  var match$1 = match.tl;
  if (!match$1) {
    return ;
  }
  var match$2 = match$1.tl;
  if (!match$2) {
    return ;
  }
  var match$3 = match$2.tl;
  if (!match$3) {
    return ;
  }
  var match$4 = match$3.tl;
  if (!match$4) {
    return ;
  }
  var match$5 = match$4.tl;
  if (!match$5) {
    return ;
  }
  var match$6 = match$5.tl;
  if (match$6 && !match$6.tl) {
    return {
            byr: li.hd,
            iyr: match.hd,
            eyr: match$1.hd,
            hgt: match$2.hd,
            hcl: match$3.hd,
            ecl: match$4.hd,
            pid: match$5.hd,
            cid: match$6.hd
          };
  }
  
}

console.log(Belt_Array.keepMap(Belt_List.toArray(Belt_List.keepMap(Belt_List.map(Belt_List.fromArray(Belt_Array.map(input, toSingleLine)), apply), sequence)), listToPassport));

exports.input = input;
exports.$$require = $$require;
exports.id = id;
exports.parsing = parsing;
exports.judge = judge;
exports.toSingleLine = toSingleLine;
exports.sequence = sequence;
exports.intCheck = intCheck;
exports.extractIntAndCheck = extractIntAndCheck;
exports.extractStr = extractStr;
exports.byrRe = byrRe;
exports.iyrRe = iyrRe;
exports.eyrRe = eyrRe;
exports.hgtRe = hgtRe;
exports.hclRe = hclRe;
exports.eclRe = eclRe;
exports.pidRe = pidRe;
exports.cidRe = cidRe;
exports.parseYear = parseYear;
exports.checkHgt = checkHgt;
exports.extractHgt = extractHgt;
exports.parseHgt = parseHgt;
exports.parseStr = parseStr;
exports.apply = apply;
exports.listToPassport = listToPassport;
/* input Not a pure module */
