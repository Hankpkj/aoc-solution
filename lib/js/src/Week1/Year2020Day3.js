// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Caml_int32 = require("rescript/lib/js/caml_int32.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");

var input = Fs.readFileSync("input/Week1/Year2020Day3.sample.txt", "utf8");

var arr = Belt_List.fromArray(input.split("\n"));

var rowLength = Belt_Option.mapWithDefault(Belt_List.head(arr), 0, (function (prim) {
        return prim.length;
      }));

function specific(param) {
  return Belt_List.length(Belt_List.keep(Belt_List.mapWithIndex(Belt_List.map(Belt_List.keep(arr, (function (a) {
                                return a !== "";
                              })), (function (str) {
                            return str.split("");
                          })), (function (idx, arr) {
                        return Caml_array.get(arr, Math.imul(idx, 3) - Math.imul(Caml_int32.div(Math.imul(idx, 3), rowLength), rowLength) | 0);
                      })), (function (x) {
                    return x === "#";
                  })));
}

function findTrees(arr, dir) {
  var col = dir.col;
  var row = dir.row;
  var rowLength = Belt_Option.map(Belt_List.head(arr), (function (prim) {
          return prim.length;
        }));
  if (rowLength !== undefined) {
    return Belt_List.length(Belt_List.keep(Belt_List.mapWithIndex(Belt_List.map(Belt_List.keep(Belt_List.keepWithIndex(arr, (function (param, idx) {
                                      return Caml_int32.mod_(idx, row) === 0;
                                    })), (function (a) {
                                  return a !== "";
                                })), (function (str) {
                              return str.split("");
                            })), (function (idx, arr) {
                          return Caml_array.get(arr, Caml_int32.mod_(Math.imul(idx, col), rowLength));
                        })), (function (x) {
                      return x === "#";
                    })));
  } else {
    return 0;
  }
}

var directions = {
  hd: {
    row: 1,
    col: 1
  },
  tl: {
    hd: {
      row: 1,
      col: 3
    },
    tl: {
      hd: {
        row: 1,
        col: 5
      },
      tl: {
        hd: {
          row: 1,
          col: 7
        },
        tl: {
          hd: {
            row: 2,
            col: 1
          },
          tl: /* [] */0
        }
      }
    }
  }
};

function parser(param) {
  return findTrees(arr, param);
}

console.log(Belt_List.reduce(Belt_List.map(directions, parser), 1, (function (acc, cur) {
            return Math.imul(acc, cur);
          })));

exports.input = input;
exports.arr = arr;
exports.rowLength = rowLength;
exports.specific = specific;
exports.findTrees = findTrees;
exports.directions = directions;
exports.parser = parser;
/* input Not a pure module */
