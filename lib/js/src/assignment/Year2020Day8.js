// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Input = require("../Util/input.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_SetInt = require("rescript/lib/js/belt_SetInt.js");

var arr = Input.Input.getInput(/* Single */0, 8);

function id(t) {
  return t;
}

function toInstruction(s) {
  var match = s.split(" ", 2);
  if (match.length !== 2) {
    return ;
  }
  var match$1 = match[0];
  switch (match$1) {
    case "acc" :
        var v = match[1];
        return {
                TAG: /* Acc */1,
                _0: Belt_Option.getExn(Belt_Int.fromString(v))
              };
    case "jmp" :
        var v$1 = match[1];
        return {
                TAG: /* Jmp */0,
                _0: Belt_Option.getExn(Belt_Int.fromString(v$1))
              };
    case "nop" :
        return /* Nop */0;
    default:
      return ;
  }
}

function judge(res, log, ci, cv) {
  var ni = res._0;
  if (Belt_SetInt.has(log, ni)) {
    return {
            TAG: /* Fail */1,
            _0: ci,
            _1: cv
          };
  } else {
    return {
            TAG: /* Success */0,
            _0: ni,
            _1: res._1
          };
  }
}

function action(p) {
  var instr = p.instr;
  var currentValue = p.currentValue;
  var currentIdx = p.currentIdx;
  var tmp;
  tmp = typeof instr === "number" ? /* Result */({
        _0: currentIdx + 1 | 0,
        _1: currentValue
      }) : (
      instr.TAG === /* Jmp */0 ? /* Result */({
            _0: currentIdx + instr._0 | 0,
            _1: currentValue
          }) : /* Result */({
            _0: currentIdx + 1 | 0,
            _1: currentValue + instr._0 | 0
          })
    );
  return judge(tmp, p.idxLog, currentIdx, currentValue);
}

var instrArr = Belt_Array.keepMap(arr, toInstruction);

function makePendingData(ci, cv, l, instr) {
  return {
          currentIdx: ci,
          currentValue: cv,
          idxLog: l,
          instr: instr
        };
}

var length = instrArr.length;

function $$do(_log, _currentIdx, _currentValue, noBlockIdx) {
  while(true) {
    var currentValue = _currentValue;
    var currentIdx = _currentIdx;
    var log = _log;
    if (currentIdx >= length) {
      return {
              TAG: /* Finish */1,
              _0: currentIdx,
              _1: currentValue
            };
    }
    var instr = currentIdx === noBlockIdx ? /* Nop */0 : Belt_Array.getExn(instrArr, currentIdx);
    var pd = makePendingData(currentIdx, currentValue, log, instr);
    var match = action(pd);
    if (match.TAG !== /* Success */0) {
      return {
              TAG: /* Block */0,
              _0: match._0,
              _1: match._1,
              _2: noBlockIdx,
              _3: log
            };
    }
    _currentValue = match._1;
    _currentIdx = match._0;
    _log = Belt_SetInt.add(log, currentIdx);
    continue ;
  };
}

var exampleOneResult = $$do(undefined, 0, 0, length);

if (exampleOneResult.TAG === /* Block */0) {
  console.log(exampleOneResult._1);
} else {
  console.log("Finish!");
}

var jumpIdx = Belt_List.fromArray(Belt_Array.keepMap(Belt_Array.mapWithIndex(arr, (function (idx, s) {
                if (/^jmp/.test(s)) {
                  return idx;
                }
                
              })), id));

function keepFinish(t) {
  if (t.TAG === /* Block */0) {
    return ;
  } else {
    return t._1;
  }
}

console.log(Belt_List.headExn(Belt_List.keepMap(jumpIdx, (function (idx) {
                return keepFinish($$do(undefined, 0, 0, idx));
              }))));

exports.arr = arr;
exports.id = id;
exports.toInstruction = toInstruction;
exports.judge = judge;
exports.action = action;
exports.instrArr = instrArr;
exports.makePendingData = makePendingData;
exports.length = length;
exports.$$do = $$do;
exports.exampleOneResult = exampleOneResult;
exports.jumpIdx = jumpIdx;
exports.keepFinish = keepFinish;
/* arr Not a pure module */
